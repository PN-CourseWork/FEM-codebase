================================================================================
Week 1 Sustainability Benchmarking Report - Exercise 1.7
Group 16

Authors: Philip Korsager Nickel, Aske Funch Schrøder Nielsen
Student ID(s): s214960, s224409
================================================================================

1) CPU TIME
-----------
Average CPU time (wall clock): 0.0098s
Note: Time measured using DriverSustainabilityBenchmarkingWeek1.py


2) ITERATION COUNTS
-------------------
AMR iterations: 9


3) FINAL DOF
------------
Final degrees of freedom: 74


4) HARDWARE SETUP
-----------------
Device: MacBook Pro M3 pro 
Operating System: macOS 24.6.0 (Darwin)
Python Version: 3.14.2
Processor: Apple Silicon M-series
Estimated Power Consumption: 86 W 

5) CO2eq CONSUMPTION ESTIMATE
------------------------------
Formula used:
    CO2eq = (t_CPU / 3600) * (P / 1000) * C

where:
    t_CPU = CPU time [seconds]
    P = Power consumption [Watts] = 86 W
    C = CO2 intensity [kg CO2/kWh] = 0.135 kg CO2/kWh

Units conversion:
    t_CPU / 3600: converts seconds to hours
    P / 1000: converts Watts to kiloWatts

Estimated CO2eq: 3.16 × 10e-8 kg CO2 

6) ERROR TOLERANCE AND CODE
----------------------------
Error tolerance: tol = 1e-4
Initial mesh configuration: x = [0.0, 0.5, 1.0] (M = 3 nodes, 2 elements)

Error measure implementation:
The error estimator uses a two-grid L2 estimator that compares solutions
on coarse mesh (h) versus uniformly refined fine mesh (h/2):

    η_e = ||u_fine - I_h(u_coarse)||_L2  for each element e

where I_h is the piecewise linear interpolant from coarse to fine mesh.

The error is computed element-wise and the maximum error is compared against
the tolerance. Elements are marked for refinement using absolute marking
with α = 1.0.

See implementation in: src/FEM/amr.py, function estimate_error_l2()


7) AMR STRATEGY
---------------
Adaptive Mesh Refinement Strategy:

a) Initial mesh: 2 uniform elements on [0, 1]

b) Iterative refinement loop:
   1. Solve -u'' + u = f on current coarse mesh
   2. Uniformly refine all elements to create fine mesh
   3. Solve on fine mesh
   4. Estimate element-wise errors using two-grid L2 estimator
   5. Mark elements where error > tolerance (absolute marking, α = 1.0)
   6. If max error < tolerance OR no elements marked: STOP
   7. Refine marked elements by bisection
   8. Return to step 1

c) Marking strategy: Absolute marking with α = 1.0
   All elements with error η_e > tolerance are marked for refinement.

d) Refinement method: Midpoint bisection
   Each marked element [x_i, x_{i+1}] is split into two elements
   [x_i, x_mid] and [x_mid, x_{i+1}] where x_mid = (x_i + x_{i+1})/2.


9) OTHER RELEVANT INFORMATION
------------------------------
- Implementation: Python 3.14.2 with NumPy, SciPy, Numba (JIT compilation)
- Verification: Solution visually matches exact manufactured solution

